kernel handling:

The IPythonKernel inherits from ipykernel.kernelbase.Kernel = base class that talks to frontends over 0MQ (aliased to KernelBase)

ipykernel.ipkernel.IPythonKernel                    ipykernel.inprocess.ipkernel.InProcessKernel
================================                    ============================================






The jupyter_client.client.KernelClient:
    inherits from jupyter_client.connect.ConnexionFileMixin
    
    communicates with a single kernel on any host via 0mq channels 
    
    channels are defined in jupyter_client.channels and jupyter_client.channelabc
    jupyter_client.channels only defines HBChannel which also inherits from threading.Thread

    Each kernel associates four 0mq channels:
        The first three inherit from ChannelABC
        shell --> request/replay calls to the kernel
        iopub --> used by kernel to publish results to frontends
        stdin --> used by frontends to reply to raw_input calls in the kernel
        
        hb    --> monitors the kernel heartbeat; inherits from HBChannelABC
        
        messages that can be sent on these channels are exposed as methods of the client;
        these methods only send the message -- do not wat for a reply
        to get results use methods to fetch messages from the channel: (calls get_msg method
                                                                        of the channel class)
            ----------------------------------------------------------
            method <-- channel
            -----------------
            get_shell_msg <-- self.shell_channel.get_msg
            get_iopub_msg <-- self.iopub_channel.get_msg
            get_stdin_msg <-- self.stdin_chanel.get_msg
            
        NOTE: there is no such method for the hb channel
        
        NOTE: all the self.*_channel are in fact properties:
                they point to a class member but instance-specific e.g. self._shell_channel
                which is a channel-specific ChannelABC generated dynamically by ConnexionFileMixin
                    from a 0mq URL i.e. a string with either:
                        a tcp url "tcp://ip_address:port", or 
                        an iterprocess communication protocol "ipc://ip_address-port")
                    and a corresponding socket in zmq package
                    (effectively, connection files)
        
    "starts" the kernel, i.e. starts the channels for this kernel (arguments specify which channel is to be started):
        kernel_client.start_channels(shell=True, iopub=True, stdin=True, hb=True)
    

ScipyenConsole uses an in-process ipython kernel:
    the manager = qtconsole.inprocess.QtInProcessKernelManager <- 
                    <- ipykernel.inprocess.manager.InProcessKernelManager <- 
                        <- jupyter_client.manager.KernelManager
        
    starts the kernel with manager.start_kernel() 
        start_kernel is ipykernel.inprocess.manager.InProcessKernelManager.start_kernel() which:
            overrides jupyter_client.manager.KernelManager.start_kernel()
            
            creates the kernel = an instance of ipykernel.inprocess.ipkernel.InProcessKernel <-
                    <- ipykernel.ipkernel.IPythonKernel
                    
                this is an in-process kernel (as opposed to ipykernel.ipkernel.IPythonKernel):
                
                class members:
                    frontends - a traitlets.List (hence references to) one instance of ipykernel.inprocess.client.InProcessKernelClient
                    
                    gui = traitlets.Enum(('tk', 'gtk', 'wx', 'qt', 'qt4', 'inline'),
                            default_value='inline') # GUI environment, default is "inline"
                    
                    raw_input_str = traitlets.Any()
                    
                    stdout = traitlets.Any()
                    
                    stderr = traitlets.Any()
                    
                    shell_class = traitlets.Type(allow_none=True)
                    
                    shell_streams = traitlets.List()
                    
                    
                    control_stream = traitlets.Any()
                    
                    _underlying_iopub_socket = traitlets.Instance(traitlets.DummySocket, ())
                    
                    iopub_thread = traitlets(ipykernel.iostream.IOPubThread) (inherits directly from object)
                            sends IOPub messages in a background thread (so that a blocking mean thread does not delay output from threads)
                            has its own io loop (zmq.eventloop.ioloop.IOLoop)
                    
                constructor:
                    arguments: **traits -- passed to IPythonKernel constructor then upwards via
                        traitlets.config.configurable.SingletonConfigurable to traitlets.config.configurable.Configurable
                        and up to HasTraits ad MetaHasTraits etc
                        
